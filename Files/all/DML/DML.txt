:=================?==================:
?
 Укороченная запись условия: (логика) ? правда : ложь. Подробнее – в этом уроке.
int с = (a > b) ? 10 : -20;  // если a > b, то с = 10. Если нет, то с = -20



Название	Альт. название  	Вес	Диапазон	                        			 Особенность
boolean	        bool	              1 байт	0 или 1, true или false	              			 Логическая переменная. bool на Arduino тоже занимает 1 байт, а не бит!
char	        int8_t	              1 байт	-128… 127	                       			Хранит номер символа из таблицы символов ASCII
byte	        uint8_t	              1 байт	0… 255	 
int	        int16_t, short	      2 байта	-32 768… 32 767	 
unsigned int	uint16_t, word	      2 байта	0… 65 535	 
long	        int32_t	              4 байта	-2 147 483 648… 2 147 483 647         			– 2 миллиарда… 2 миллиарда
unsigned long	uint32_t	      4 байта	0… 4 294 967 295	               			0… 4 миллиарда…
float	           –	              4 байта	-3.4028235E+38… 3.4028235E+38	       			Хранит числа с плавающей точкой (десятичные дроби). Точность: 6-7 знаков
double	           –	              4 байта	Для AVR то же самое, что float. А так он 8 байт
–	        int64_t	              8 байт	-(2^64)/2… (2^64)/2-1					Очень большие числа. Serial не умеет такие выводить
–	        uint64_t	      8 байт	2^64-1	         					Очень большие числа. Serial не умеет такие выводить

wchar_t – 16 битный символ
char16_t – 2-х байтный char
char32_t – 4-х байтный char



struct <ярлык> {
  <тип> <имя переменной 1>;
  <тип> <имя переменной 2>;
  <тип> <имя переменной 3>;
};

enum <ярлык> {<имя1>, <имя2>, <имя3>, <имя4>, <имя5>};

class /*имя класса*/
{
  private:
  // список свойств и методов для использования внутри класса
  public:
  // список методов доступных другим функциям и объектам программы
  protected:
  // список средств, доступных при наследовании
};



// указываем количество ячеек и всё, дальше можно с ними работать
int myInts[6];
// указываем содержимое ячеек, компилятор сам посчитает их количество
int myPins[] = {2, 4, 8, 3, 6};
// указываем и то и то, количество ячеек в [ ] должно совпадать с { } или быть больше!
float Sens[3] = {0.2, 0.4, -8.5};
// храним символы
char message[6] = "hello";
// помним, что порядок ячеек начинается с нуля!
myInts[0] = 10;   // записать 10 в ячейку 0 массива myInts



String string0 = "Hello String";              // заполняем словами в кавычках
String string1 = String("lol ") + String("kek");  // сумма двух строк
String string2 = String('a');                 // строка из символа в одинарных кавычках
String string3 = String("This is string");    // конвертируем строку в String
String string4 = String(string3 + " more");   // складываем строку string3 с текстом в кавычках
String string5 = String(13);                  // конвертируем из числа в String
String string6 = String(20, DEC);             // конвертируем из числа с указанием базиса (десятичный)
String string7 = String(45, HEX);             // конвертируем из числа с указанием базиса (16-ричный)
String string8 = String(255, BIN);            // конвертируем из числа с указанием базиса (двоичный)
String string9 = String(5.698, 3);            // из float с указанием количества знаков после запятой (тут 3)
// можно формировать название из кусочков, например для работы с файлами
#define NAME "speed"
#define TYPE "-log"
#define EXT ".txt"
// при сложении достаточно указать String 1 раз для первой строки
String filename = String(NAME) + TYPE + EXT;  // filename будет равна speed-log.txt
// доступ к элементу строки работает по такому же механизму, как массив
string1[0] = "a";
// теперь вместо Hello String у нас aello String



const – константа, такую переменную нельзя изменить (будет ошибка). const int val = 10;
static – позволяет объявить локальную переменную внутри функции, и эта переменная не будет заново переобъявляться при повторном вызове функции. Эдакая локальная глобальная переменная. Почитать
volatile – указывает компилятору, что переменную не нужно оптимизировать, что её значение может меняться извне. Такой спецификатор должен быть применён к переменным, которые меняют своё значение в прерывании. Почитать
extern – указывает компилятору, что эта переменная объявлена в другом файле программы, но мы хотим пользоваться именно ей, а не создавать новую с таким же именем в этом файле программы. Позволяет читать/записывать в переменные, созданные в других файлах (библиотеках)!



random(max) – возвращает случайное число в диапазоне от 0 до (max – 1)
random(min, max) – возвращает случайное число в диапазоне от min до (max – 1)
randomSeed(value)



malloc() – выделение памяти
free() – освобождение памяти
new() – выделение памяти (полный аналог malloc)
delete() – освобождение памяти (полный аналог free)
memset() – заполняет блоки памяти по адресу
:=================#==================:
#include
#include <Servo.h>  // подключает библиотеку Servo.h
#include "Servo.h"  // подключает библиотеку Servo.h
#define
#if, #elif, #else, #endif
#ifdef, #ifndef
typedef <тип> <имя>;
:================def=================:
:================yes=================:
goto

if, else if, else
switch.. case

= присваивание
% остаток от деления
* умножение
/ деление
+ сложение
– вычитание

== равенство (a == b)
!= неравенство (a != b)
>= больше или равно
<= меньше или равно
> больше
< меньше
! логическое НЕ, отрицание. Аналог – оператор not
&& логическое И. Аналог – оператор and
|| логическое ИЛИ. Аналог – оператор or

++ (плюс плюс) инкремент: a++ равносильно a = a + 1
-- (минус минус) декремент: a -- равносильно a = a – 1
+= составное сложение: a += 10 равносильно a = a + 10
-= составное вычитание: a -= 10 равносильно a = a – 10
*= составное умножение: a *= 10 равносильно a = a * 10
/= составное деление: a /= 10 равносильно a = a / 10
%= прибавить остаток от деления: a %= 10 равносильно a = a + a % 10
&= составное битовое И: a &= b равносильно a = a & b
^= составное исключающее ИЛИ: a ^= b равносильно a = a ^ b
|= составное ИЛИ: a |= b равносильно a = a | b

& битовое И
<< битовый сдвиг влево
>> битовый сдвиг вправо
^ битовое исключающее ИЛИ (аналогичный оператор – xor)
| битовое ИЛИ
~ битовое НЕ



Базис	Префикс	Пример	Особенности
2 (двоичная)	B или 0b (ноль бэ)	B1101001	цифры 0 и 1
8 (восьмеричная)	0 (ноль)	0175	цифры 0 – 7
10 (десятичная)	нет	100500	цифры 0 – 9
16 (шестнадцатеричная)	0x (ноль икс)	0xFF21A	цифры 0-9, буквы A-F

u или U – перевод в формат unsigned int (от 0 до 65’535). Пример: 36000u
l или L – перевод в формат long (-2 147 483 648… 2 147 483 647). Пример: 325646L
ul или UL – перевод в формат unsigned long (от 0 до 4 294 967 295). Пример: 361341ul



attachInterrupt(pin, ISR, mode)

LOW – срабатывает при сигнале LOW на пине
RISING – срабатывает при изменении сигнала на пине с LOW на HIGH
FALLING – срабатывает при изменении сигнала на пине с HIGH на LOW 
CHANGE – срабатывает при изменении сигнала (с LOW на HIGH и наоборот)

detachInterrupt(pin)
interrupts()
noInterrupts()



F_CPU				Частота процессора в Гц
__DATE__			Дата компиляции в формате Feb 28 2019
__TIME__



bit(val) – считает значение байта val по порядку (0 будет 1, 1 будет 2, 2 будет 4, 3 будет 8 и.т.д.)
bitClear(x, n) – устанавливает на 0 бит, находящийся в числе x под номером n
bitSet(x, n) – устанавливает на 1 бит, находящийся в числе x под номером n
bitWrite(x, n, b) – устанавливает на значение b (0 или 1) бит , находящийся в числе x под номером n
bitRead(x, n) – возвращает значение бита (0 или 1), находящегося в числе x под номером n
highByte(x) – извлекает и возвращает старший (крайний левый) байт переменной типа word (либо второй младший байт переменной, если ее тип занимает больше двух байт).
lowByte(x) – извлекает и возвращает младший (крайний правый) байт переменной (например, типа word).
bit_is_set(x, n) – проверка (возвращает 1 если включен) бита n в числе x
bit_is_clear(x, n) – проверка (возвращает 1 если выключен) бита n в числе x
loop_until_bit_is_set(x, n) – висеть в цикле (ждать), пока включен бит n в числе x
loop_until_bit_is_clear(x, n)
:====================================:
/* */
//
;
void function() {}
return






for
while
do.. while
continue
break



Запятая ,
Запятая тоже является оператором, используется в следующих случаях:

Перечисление элементов в массивах (урок про массивы)
Перечисление аргументов в функциях (урок про функции)
Выполнение последовательности действий (сделать это И это)



& – возвращает адрес данных в памяти (адрес первого блока данных)
* – возвращает значение по указанному адресу
-> – оператор косвенного обращения к членам и методам (для указателей на структуры и классы). Является короткой записью конструкции через указатель: a->b равносильно (*a).b






























charAt()
myString.charAt(index);
setCharAt()
myString.setCharAt(index, val);
compareTo()
myString.compareTo(myString2);
concat()
myString.concat(value);
endsWith()
myString.endsWith(myString2);
startsWith()
myString.startsWith(myString2);
equals()
myString.equals(myString2);
equalsIgnoreCase()
myString.equalsIgnoreCase(myString2);
indexOf()
myString.indexOf(val);
myString.indexOf(val, from);
lastIndexOf()
myString.lastIndexOf(val);
myString.lastIndexOf(val, from);
length()
remove()
myString.remove(index);
myString.remove(index, count);
replace()
reserve()
myString.reserve(size);
c_str()
myString.c_str();
trim()
myString.trim();
substring()reserve()
myString.reserve(size);
c_str()
myString.c_str();
trim()
myString.trim();
substring()
toCharArray()
myString.toCharArray(buf, len);
getBytes()
myString.getBytes(buf, len);
toFloat()
myString.toFloat();
toDouble()
myString.toDouble();
toInt()
myString.toInt();
String myString = "10500";
int val = myString.toInt();
toLowerCase()
myString.toLowerCase();
toUpperCase()










toInt()
toFloat()
toCharArray()




reinterpret_cast – приведение типов без проверки, непосредственное указание компилятору. Применяется только в случае полной уверенности программиста в собственных действиях. Не снимает const и volatile, применяется для приведения указателя к указателю, указателя к целому и наоборот;
static_cast – преобразует выражения одного статического типа в объекты и значения другого статического типа. Поддерживается преобразование численных типов, указателей и ссылок по иерархии наследования как вверх, так и вниз. Преобразование проверяется на уровне компиляции и в случае ошибки приведения типов будет выдано сообщение;
dynamic_cast – используется для динамического приведения типов во время выполнения. В случае неправильного приведения типов для ссылок вызывается исключительная ситуация std::bad_cast, а для указателей будет возвращен 0;
const_cast – самое простое приведение типов. Снимает const и volatile, то есть константность и отказ от оптимизации компилятором переменной. Это преобразование проверяется на уровне компиляции и в случае ошибки приведения типов будет выдано сообщение.




isAlpha(thisChar) – возвращает true, если thisChar – буква
isAlphaNumeric(thisChar) – возвращает true, если thisChar – буква или цифра
isAscii(thisChar) – возвращает true, если thisChar входит в таблицу ASCII
isControl(thisChar) – возвращает true, если thisChar – контрольный символ
isDigit(thisChar) – возвращает true, если thisChar – цифра
isGraph(thisChar) – возвращает true, если thisChar – печатаемый знак (кроме пробела)
isPrintable(thisChar) – возвращает true, если thisChar – печатаемый знак (включая пробел)
isHexadecimalDigit(thisChar) – возвращает true, если thisChar цифра 0-9 или буква A-F
isPunct(thisChar) – возвращает true, если thisChar – знак пунктуации
isLowerCase(thisChar) – возвращает true, если thisChar – буква в нижнем регистре (маленькая)
isUpperCase(thisChar) – возвращает true, если thisChar – буква в верхнем регистре (большая)
isSpace(thisChar) – возвращает true, если thisChar – пробел
isWhitespace(thisChar) – возвращает true, если thisChar – форматированный пробел (formfeed (‘\f’), newline (‘\n’), carriage return (‘\r’), horizontal tab (‘\t’), and vertical tab (‘\v’))













long val;
val = 2000000000 + 6000000;         // посчитает корректно (т.к. сложение)
val = 25 * 1000;                    // посчитает корректно (умножение, меньше 32'768)
val = 35 * 1000;                    // посчитает НЕКОРРЕКТНО! (умножение, больше 32'768)
val = (long)35 * 1000;              // посчитает корректно (выделяем память (long) )
val = 35 * 1000L;                   // посчитает корректно (модификатор L)
val = 35 * 1000u;                   // посчитает корректно (модификатор u)
val = 70 * 1000u;                   // посчитает НЕКОРРЕКТНО (модификатор u, результат > 65535)
val = 1000 + 35 * 10 * 100;         // посчитает НЕКОРРЕКТНО! (в умножении больше 32'768)
val = 1000 + 35 * 10 * 100L;        // посчитает корректно! (модификатор L)
val = (long)35 * 1000 + 35 * 1000;  // посчитает НЕКОРРЕКТНО! Второе умножение всё портит
val = (long)35 * 1000 + (long)35 * 1000;  // посчитает корректно (выделяем память (long) )
val = 35 * 1000L + 35 * 1000L;      // посчитает корректно (модификатор L)





Тип записи	Пример	Чему равно
Десятичная дробь	20.5	20.5
Научный	2.34E5	2.34*10^5 или 234000
Инженерный	67e-12	67*10^-12 или 0.000000000067






float val;
val = 100 / 3;          // посчитает НЕПРАВИЛЬНО (результат 3.0)
val = (float)100 / 3;   // посчитает правильно (указываем (float))
val = 100.0 / 3;        // посчитает правильно (есть число float)
val = 100 / 3.0;        // посчитает правильно (есть число float)
float val2 = 100;
val = val2 / 3;         // посчитает правильно (есть число float)




int val;
val = 3.25;         // val принимает 3
val = 3.92;         // val принимает 3
val = round(3.25);  // val принимает 3
val = round(3.92);  // val принимает 4


















pinMode(pin, mode)
INPUT – вход (все пины сконфигурированы так по умолчанию)
OUTPUT – выход (при использовании analogWrite ставится автоматически)
INPUT_PULLUP – подтяжка к питанию (например для обработки кнопок)

digitalRead(pin)
digitalWrite(pin, value)
analogWrite(pin, value)
analogRead(pin)
analogReference(mode)
DEFAULT: опорное напряжение равно напряжению питания МК
INTERNAL: встроенный источник опорного на 1.1V для ATmega168 или ATmega328P и 2.56V на ATmega8
INTERNAL1V1: встроенный источник опорного на 1.1V (только для Arduino Mega)
INTERNAL2V56: встроенный источник опорного на 2.56V (только для Arduino Mega)
EXTERNAL: опорным будет считаться напряжение, поданное на пин AREF


tone(pin, frequency), tone(pin, frequency, duration)
noTone(pin)
pulseIn(pin, value), pulseIn(pin, value, timeout)
pulseInLong(pin, value), pulseInLong(pin, value, timeout)
shiftIn(dataPin, clockPin, bitOrder)
shiftOut(dataPin, clockPin, bitOrder, value)



Serial



delay(time)
delayMicroseconds(time)
millis()
micros()


HIGH и LOW			1 и 0 соответственно
INPUT, OUTPUT, INPUT_PULLUP	0, 1 и 2 соответственно
SERIAL, DISPLAY			0 и 1 соответственно
LSBFIRST, MSBFIRST		0 и 1 соответственно
CHANGE, FALLING, RISING		1, 2 и 3 соответственно
			Время компиляции в формате 14:12:12









sizeof(variable)
PROGMEM
pgm_read_byte(data); – для 1-го байта (char, byte, int8_t, uint8_t)
pgm_read_word(data); – для 2-х байт (int, word, unsigned int, int16_t, int16_t)
pgm_read_dword(data); – для 4-х байт (long, unsigned long, int32_t, int32_t)
pgm_read_float(data); – для чисел с плавающей точкой
const int16_t ints[] PROGMEM = {65000, 32796, -16843};
Serial.println((int)pgm_read_word(&(ints[2]))); 
F() macro






















export – слово не используется (зарезервировано), читать тут
virtual – спецификатор виртуальной функции, читать тут
yield() – часть библиотеки Schelduer для создания “многопоточности”. Читать тут
complex – комплексный класс. Читать тут
explict – позволяет создать неконвертирующий конструктор
union – объект “объединение”, читать тут
friend – дружественные функции, читать тут
NULL и null – пустые указатели
























register – данный спецификатор указывает компилятору хранить значение переменной не в памяти, а в регистре процессора
auto – не имеет смысла
mutable – позволяет создать “неприкосновенный” объект






















verride – модификатор
final – модификатор
try – попытка
throw – вызов исключения
catch – обработка исключения
namespace – создание пространства имён
using – позволяет использовать имя из пространства имён без оператора ::